---
sidebar_position: 2
sidebar_label: Понимание потребностей
---

# О понимании потребностей и о формулировке задач

:::note TL;DR

— _Не получается сформулировать цель, которую будет решать новая фича? А может проблема в том, что сама задача не сформулирована? **Смысл ещё и в том, чтобы методология помогла вытащить наружу проблемное определение задач и целей**_

— _Проект не живет в статике - требования и функциональность постоянно меняются. Со временем, код превращается в кашу, т.к. на старте проект был спроектирован только под изначальный слепок пожеланий. **И задача хорошей архитектуры в том числе - чтобы быть заточенной под изменяющиеся условия разработки.**_

:::

<!--TODO: Сделать каждый раздел позднее более самостоятельным сам по себе -->
<!--TODO: Добавить больше информации по изменяющимся требованиям проекта -->

## Зачем? {#why}

Чтобы подобрать четкое имя сущности и понять ее составляющие, **нужно отчетливо понимать - какая задача будет решена с помощью всего этого кода.**

> _@sergeysova: Во время разработки, мы пытаемся каждой сущности или функции дать имя, которое четко отражает намерения и смысл выполняемого кода._

_Ведь, без понимания задачи, нельзя написать правильные тесты, покрывающие самые важные кейсы, проставить ошибки помогающие пользователю в нужных местах, даже банально не прерывать флоу пользователя из-за исправимых не критичных ошибок._

## О каких задачах речь? {#what-tasks-are-we-talking-about}

Frontend занимается разработкой приложений и интерфейсов для конечных пользователей, значит мы решаем задачи этих потребителей.

Когда к нам приходит человек, **он хочет решить какую-то свою боль или закрыть потребность.**

_Задача менеджеров и аналитиков - сформулировать эту потребность, а разработчиков реализовать с учетом особенностей веб-разработки (потеря связи, ошибка бэкенда, опечатка, промазал курсором или пальцем)._

**Эта самая цель, с которой пришёл пользователь и есть задача разработчиков.**

> _Одна маленькая решенная задача и есть feature в методологии Feature-Sliced Design — нужно нарезать весь скоуп задач проекта на маленькие цели._

## Как это влияет на разработку? {#how-does-this-affect-development}

### Декомпозиция задачи {#task-decomposition}

Когда разработчик принимается реализовывать задачу, для упрощения понимания и поддержки кода, он мысленно **нарезает ее на этапы**:

- сначала _разбить на верхнеуровневые сущности_ и _реализовать их_,
- затем эти сущности _разбить на более мелкие_
- и так далее

_В процессе разбиения на сущности, разработчик вынужден дать им название, которое четко отражало бы его замысел и при чтении листинга помогало понять какую задачу решает код_

_При этом не забываем, что пытаемся помочь пользователю уменьшить боль или реализовать потребности_

### Понимание сути задачи {#understanding-the-essence-of-the-task}

Но чтобы дать четкое название сущности, **разработчик должен знать предостаточно о ее назначении**

- как он собирается использовать эту сущность,
- какую часть задачи пользователя она реализует, где ещё эту сущность можно применить,
- в каких ещё задачах она может поучаствовать,
- и так далее

Сделать вывод не сложно: **пока разработчик будет размышлять над названием сущностей в рамках методологии, он сможет найти плохо сформулированные задачи ещё до написания кода.**

> Как дать название сущности, если плохо понимаешь, какие задачи она может решать, как вообще можно разбить задачу на сущности, если плохо ее понимаешь?

## Как сформулировать? {#how-to-formulate-it}

**Чтобы сформулировать задачу, которая решается фичей, нужно понимать саму задачу**, а это уже область ответственности менеджера проекта и аналитиков.

_Методология может лишь подсказать разработчику, на какие задачи стоит обратить пристальное внимание менеджеру продукта._

> _@sergeysova: Весь frontend это в первую очередь отображение информации, любой компонент в первую очередь что-то отображает, а значит задача "показать пользователю что-то" не имеет практической ценности._
>
> _Даже без учета специфики frontend можно спросить "а зачем это нужно показывать", так можно продолжать спрашивать до тех пор пока не вылезет боль или потребность потребителя._

Как только мы смогли дойти до базовых потребностей или болей, можно идти обратно и разбираться, **а как именно ваш продукт или сервис может помочь пользователю с его целями**

Любая новая задача в вашем трекере направлена на решение задач бизнеса, а бизнес пытается решить задачи пользователя одновременно заработав на нём. А значит, каждая задача несёт в себе определенные цели, даже если они не прописаны в тексте описания.

_**Разработчик должен четко понимать, какую цель преследует та или иная задача**, но при этом не каждая компания может позволить себе идеально выстроить процессы, хоть это и отдельный разговор, тем не менее, разработчик вполне может сам "пингануть" нужных менеджеров, чтобы выяснить это и сделать свою часть работы эффективно._

## А в чем выгода? {#and-what-is-the-benefit}

Посмотрим теперь на весь процесс от начала до конца.

### 1. Понимание задач пользователей {#1-understanding-user-tasks}

Когда разработчик понимает его боли и то, как бизнес их закрывает, он может предлагать решения, которые бизнесу не доступны в силу специфики веб-разработки.

> Но конечно, все это может работать только если разработчику небезразлично то, что он делает и ради чего, а иначе _зачем тогда методология и какие-то подходы?_

### 2. Структуризация и упорядочивание {#2-structuring-and-ordering}

С пониманием задач приходит **четкая структура как в голове, так и в задачах вместе с кодом**

### 3. Понимание фичи и ее составляющих {#3-understanding-the-feature-and-its-components}

**Одна фича - это одна полезная функциональность для пользователя**

- Когда в одной фиче - реализуется несколько - это и есть **нарушение границ**
- Фича может быть неделимой и разрастающейся - **и это неплохо**
- **Плохо** - когда фича не отвечает на вопрос _"А в чем бизнес-ценность для пользователя?"_
  - Не может быть фичи `карта-офиса`
  - А вот `бронирование-переговорки-на-карте`, `поиск-сотрудника`, `смена-рабочего-места` - **да**

> _@sergeysova: Смысл в том, чтобы в фиче лежал только код, реализующий непосредственно саму функциональность, без лишних подробностей и внутренних решений (в идеале)_
>
> *Открываешь код фичи **и видишь только то, что относится к задаче** - не больше*

### 4. Profit {#4-profit}

Бизнес крайне редко разворачивает свой курс кардинально в другую сторону, а значит **отражение задач бизнеса в коде frontend приложения это весьма существенный профит.**

_Тогда не придётся объяснять каждому новому члену команды, что делает тот или иной код, и вообще ради чего он добавлялся - **все будет объясняться через задачи бизнеса, которые уже отражены в коде.**_

> То, что называется ["Язык бизнеса" в Domain Driven Development][ext-ubiq-lang]

---

## Вернемся к реальности {#back-to-reality}

Если бизнес-процессы осмыслены и на стадии дизайна даны хорошие имена - _то перенести это понимание и логику в код не особо проблемно._

**Однако на деле**, задачи и функциональность обычно развиваются "слишком" итеративно и (или) нет времени продумывать дизайн.

**В итоге фича сегодня имеет смысл, а при расширении этой фичи через месяц можно переписать пол проекта.**

> *[[Из обсуждения][disc-src]]: Разработчик пытается думать на 2-3 шага вперед, учитывая будущие хотелки, но тут упирается в собственный опыт*
>
> _Прожженный опытом инженер обычно сразу смотрит на 10 шагов вперед, и понимает где одну фичу разделить, а где объединить с другой_
>
> _Но бывает и так, что приходит задача, с которой не приходилось сталкиваться по опыту, и неоткуда взять понимание - как грамотней декомпозировать, с наименьшими печальными последствиями в будущем_

## Роль методологии {#the-role-of-methodology}

**Методология помогает решить проблемы разработчиков, чтобы тем было проще решать проблемы пользователей.**

Нет решения задач разработчиков только ради разработчиков

Но чтобы разработчик решил свои задачи, **нужно понять задачи пользователя** - наоборот не выйдет

### Требования к методологии {#methodology-requirements}

Становится ясно, что нужно выделить как минимум два требования для **Feature-Sliced Design**:

1. Методология должна рассказывать **как создавать фичи, процессы и сущности**
    - А значит должна четко объяснять _как разделять код между ними_, из чего следует, что именование этих сущностей также должно быть заложено в спецификации.
2. Методология должна помогать архитектуре **[легко адаптироваться под изменяющиеся требования проекта][refs-arch--adaptability]**

## См. также {#see-also}

- [(Пост) Стимуляция к четкой формулировке задач (+ обсуждение)][disc-src]
    > _**Текущая статья** является адаптацией этого обсуждения, по ссылке можно ознакомиться с полной неурезанной версией_
- [(Обсуждение) Как разбить функциональность и что из себя она представляет][tg-src]
- [(Статья) "How to better organize your applications"][ext-medium]

[refs-arch--adaptability]: architecture#adaptability

[ext-medium]: https://alexmngn.medium.com/how-to-better-organize-your-react-applications-2fd3ea1920f1
[disc-src]: https://t.me/sergeysova/318
[tg-src]: https://t.me/atomicdesign/18972
[ext-ubiq-lang]: https://thedomaindrivendesign.io/developing-the-ubiquitous-language
